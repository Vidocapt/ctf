栈溢出，但是没有可以输出的函数
```c
nt __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [rsp+0h] [rbp-10h]

  sleep(3u);
  return read(0, &buf, 0x100uLL);
}
```

但是我们可以看到sleep函数的周围有syscall

```c
pwndbg> x/30i 0x7fd028afe680
   0x7fd028afe680 <sleep>:	push   rbp
   0x7fd028afe681 <sleep+1>:	push   rbx
   0x7fd028afe682 <sleep+2>:	mov    eax,edi
   0x7fd028afe684 <sleep+4>:	sub    rsp,0x18
   0x7fd028afe688 <sleep+8>:	mov    rbx,QWORD PTR [rip+0x2f77e9]        # 0x7fd028df5e78
   0x7fd028afe68f <sleep+15>:	mov    rdi,rsp
   0x7fd028afe692 <sleep+18>:	mov    rsi,rsp
   0x7fd028afe695 <sleep+21>:	mov    QWORD PTR [rsp+0x8],0x0
   0x7fd028afe69e <sleep+30>:	mov    QWORD PTR [rsp],rax
   0x7fd028afe6a2 <sleep+34>:	mov    ebp,DWORD PTR fs:[rbx]
   0x7fd028afe6a5 <sleep+37>:	call   0x7fd028afe730 <nanosleep>
   0x7fd028afe6aa <sleep+42>:	test   eax,eax
   0x7fd028afe6ac <sleep+44>:	js     0x7fd028afe6c0 <sleep+64>
   0x7fd028afe6ae <sleep+46>:	mov    DWORD PTR fs:[rbx],ebp
   0x7fd028afe6b1 <sleep+49>:	add    rsp,0x18
   0x7fd028afe6b5 <sleep+53>:	xor    eax,eax
   0x7fd028afe6b7 <sleep+55>:	pop    rbx
   0x7fd028afe6b8 <sleep+56>:	pop    rbp
   0x7fd028afe6b9 <sleep+57>:	ret    
   0x7fd028afe6ba <sleep+58>:	nop    WORD PTR [rax+rax*1+0x0]
   0x7fd028afe6c0 <sleep+64>:	mov    eax,DWORD PTR [rsp]
   0x7fd028afe6c3 <sleep+67>:	add    rsp,0x18
   0x7fd028afe6c7 <sleep+71>:	pop    rbx
   0x7fd028afe6c8 <sleep+72>:	pop    rbp
   0x7fd028afe6c9 <sleep+73>:	ret    
   0x7fd028afe6ca:	nop    WORD PTR [rax+rax*1+0x0]
   0x7fd028afe6d0 <pause>:	cmp    DWORD PTR [rip+0x2fd069],0x0        # 0x7fd028dfb740
   0x7fd028afe6d7 <pause+7>:	jne    0x7fd028afe6e9 <pause+25>
   0x7fd028afe6d9 <pause+9>:	mov    eax,0x22
   0x7fd028afe6de <pause+14>:	syscall 
```
由于程序的got表可写，所以可以先partial write程序的sleep@got让它指向syscall，然后就是常规利用了
